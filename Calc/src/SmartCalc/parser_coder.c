#include "s21_SmartCalc_v1.0.h"

/// @brief Прочёсывает строку и кодирует функции под односимвольные кодировки, а
/// также смотрит на корректность вводимой строки (разрешено ли вводить такие
/// символы). Если текущий символ - это первая буква одной из фукций, которую
/// нужно сократить, то срабатывает триггер и вызвается соответсвующая
/// процедура.
/// @param strIn сырая строка
/// @param strOut строка для вывода
/// @param allowVal массив разрешённых символов, которые могут встречаться
/// @return указатель на строку, которая получилась
char *parserCoder(char *strIn, char *strOut, char *X, int *error) {
  int i, j;
  for (i = 0, j = 0; strIn[i] != '\0'; i++, j++) {
    if (*error == 0) {
      *error = checkVal(strIn[i]);
      switch (strIn[i]) {
        case 's':
          parserSinSqrt(strIn, strOut, &i, j, error);
          break;
        case 'c':
          parserCos(strIn, strOut, &i, j, error);
          break;
        case 't':
          parserTan(strIn, strOut, &i, j, error);
          break;
        case 'a':
          parserAsinAcosAtan(strIn, strOut, &i, j, error);
          break;
        case 'l':
          parserLogLn(strIn, strOut, &i, j, error);
          break;
        case 'm':
          parserMod(strIn, strOut, &i, j, error);
          break;
        case '+':  // Unar || Binar
          parserUnarPlus(strIn, strOut, &i, &j);
          break;
        case '-':  // Unar || Binar
          parserUnarMin(strIn, strOut, &i, j);
          break;
        case 'X':
          parserX(strOut, &j, X, error);
          break;
        default:
          strOut[j] = strIn[i];
          break;
      }
      if (strIn[i] == '\0')
        strOut[j] = strIn[i];  //?перепроверить выходную строку
    }
  }
  return strOut;
}

/// @brief Проверочка является ли текущий символ допустимым, происходит
/// сравнение с массивом из допустимых символов allowVal
/// @param val Текущий символ
/// @return 0 - если всё хорошо, 1 - если символ не разрешён (код ошибки)
int checkVal(char val) {
  int i = 0;
  const char allowVal[28] = {'s', 'c', 't', 'a', 'l', 'm', '+', '-', '*', '/',
                             '^', '(', ')', '1', '2', '3', '4', '5', '6', '7',
                             '8', '9', '0', '.', 'X', 'e', 'P', '\0'};
  int flag = -1;
  while (allowVal[i] != '\0') {
    if (val == allowVal[i]) {
      flag = 0;
      break;
    }
    i++;
  }
  return flag;
}

/// @brief Функция parserSinSqrt предназначена для анализа входной строки strIn
/// и извлечения определенных подстрок, соответствующих функциям sin и sqrt, а
/// затем записи результата в выходную строку strOut. Эта функция также
/// обрабатывает индексы для чтения из входной строки и записи в выходную
/// строку, а также управляет флагом ошибки.
/// @param strIn Входная строка, в которой ищется подстрока, соответствующая
/// функциям sin или sqrt.
/// @param strOut Выходная строка, в которую записывается результат анализа.
/// @param i Указатель на индекс в входной строке, с которого начинается анализ.
/// @param j Индекс в выходной строке, куда записывается результат.
/// @param error Указатель на переменную, которая используется для указания
/// наличия ошибки в анализе.
void parserSinSqrt(char *strIn, char *strOut, int *i, int j, int *error) {
  int lenEnd;
  lenEnd = strlen(strIn);
  if ((*i + 2) < lenEnd && strIn[*i] == 's' && strIn[*i + 1] == 'i' &&
      strIn[*i + 2] == 'n') {
    strOut[j] = 's';
    *i += 2;
  } else if ((*i + 3) < lenEnd && strIn[*i] == 's' && strIn[*i + 1] == 'q' &&
             strIn[*i + 2] == 'r' && strIn[*i + 3] == 't') {
    strOut[j] = 'q';
    *i += 3;
  } else {
    *error = 1;  //Ошибка в написании
    strOut[j] = '\0';
  }
}
/// @brief Функция parserCos предназначена для анализа входной строки strIn
/// на наличие подстроки, соответствующей функции cos, и записи результата в
/// выходную строку strOut. Эта функция также обрабатывает индексы для
/// чтения из входной строки и записи в выходную строку, а также управляет
/// флагом ошибки.
/// @param strIn Входная строка, в которой ищется подстрока, соответствующая
/// функции cos.
/// @param strOut Выходная строка, в которую записывается результат анализа.
/// @param i Указатель на индекс в входной строке, с которого начинается анализ.
/// @param j Индекс в выходной строке, куда записывается результат.
/// @param error Указатель на переменную, которая используется для указания
/// наличия ошибки в анализе.
void parserCos(char *strIn, char *strOut, int *i, int j, int *error) {
  int lenEnd;
  lenEnd = strlen(strIn);
  if ((*i + 2) < lenEnd && strIn[*i] == 'c' && strIn[*i + 1] == 'o' &&
      strIn[*i + 2] == 's') {
    strOut[j] = 'c';
    *i += 2;
  } else {
    *error = 2;  // Ошибка ввода
    strOut[j] = '\0';
  }
}
/// @brief Функция parserTan предназначена для анализа входной строки strIn на
/// наличие подстроки, соответствующей функции tan, и записи результата в
/// выходную строку strOut. Эта функция также обрабатывает индексы для чтения из
/// входной строки и записи в выходную строку, а также управляет флагом ошибки.
/// @param strIn Входная строка, в которой ищется подстрока, соответствующая
/// функциям sin или sqrt.
/// @param strOut Выходная строка, в которую записывается результат анализа.
/// @param i Указатель на индекс в входной строке, с которого начинается анализ.
/// @param j Индекс в выходной строке, куда записывается результат.
/// @param error Указатель на переменную, которая используется для указания
/// наличия ошибки в анализе.
void parserTan(char *strIn, char *strOut, int *i, int j, int *error) {
  int lenEnd;
  lenEnd = strlen(strIn);
  if ((*i + 2) < lenEnd && strIn[*i] == 't' && strIn[*i + 1] == 'a' &&
      strIn[*i + 2] == 'n') {
    strOut[j] = 't';
    *i += 2;
  } else {
    *error = 3;
    strOut[j] = '\0';
  }
}

/// @brief Функция parserAsinAcosAtan предназначена для обработки строки,
/// содержащей математические функции asin, acos, и atan, и преобразования их в
/// соответствующие символы: y для asin, u для acos, и i для atan.
/// @param strIn Входная строка, в которой ищется подстрока, соответствующая
/// функциям sin или sqrt.
/// @param strOut Выходная строка, в которую записывается результат анализа.
/// @param i Указатель на индекс в входной строке, с которого начинается анализ.
/// @param j Индекс в выходной строке, куда записывается результат.
/// @param error Указатель на переменную, которая используется для указания
/// наличия ошибки в анализе.
void parserAsinAcosAtan(char *strIn, char *strOut, int *i, int j, int *error) {
  int lenEnd;
  lenEnd = strlen(strIn);
  if ((*i + 3) < lenEnd && strIn[*i] == 'a' && strIn[*i + 1] == 's' &&
      strIn[*i + 2] == 'i' && strIn[*i + 3] == 'n') {
    strOut[j] = 'y';
    *i += 3;
  } else if ((*i + 3) < lenEnd && strIn[*i] == 'a' && strIn[*i + 1] == 'c' &&
             strIn[*i + 2] == 'o' && strIn[*i + 3] == 's') {
    strOut[j] = 'u';
    *i += 3;
  } else if ((*i + 3) < lenEnd && strIn[*i] == 'a' && strIn[*i + 1] == 't' &&
             strIn[*i + 2] == 'a' && strIn[*i + 3] == 'n') {
    strOut[j] = 'i';
    *i += 3;
  } else {
    *error = 4;
    strOut[j] = '\0';
  }
}

/// @brief Функция parserLogLn предназначена для обработки строки, содержащей
/// математические функции log и ln, и преобразования их в соответствующие
/// символы: g для log и n для ln.
/// @param strIn Входная строка, в которой ищется подстрока, соответствующая
/// функциям sin или sqrt.
/// @param strOut Выходная строка, в которую записывается результат анализа.
/// @param i Указатель на индекс в входной строке, с которого начинается анализ.
/// @param j Индекс в выходной строке, куда записывается результат.
/// @param error Указатель на переменную, которая используется для указания
/// наличия ошибки в анализе.
void parserLogLn(char *strIn, char *strOut, int *i, int j, int *error) {
  int lenEnd;
  lenEnd = strlen(strIn);
  if ((*i + 2) < lenEnd && strIn[*i] == 'l' && strIn[*i + 1] == 'o' &&
      strIn[*i + 2] == 'g') {
    strOut[j] = 'g';
    *i += 2;
  } else if ((*i + 1) < lenEnd && strIn[*i] == 'l' && strIn[*i + 1] == 'n') {
    strOut[j] = 'n';
    *i += 1;
  } else {
    *error = 5;
    strOut[j] = '\0';
  }
}

/// @brief Функция parserMod предназначена для обработки строки, содержащей
/// математическое выражение mod, и преобразования его в соответствующий символ:
/// m.
/// @param strIn Входная строка, в которой ищется подстрока, соответствующая
/// функциям sin или sqrt.
/// @param strOut Выходная строка, в которую записывается результат анализа.
/// @param i Указатель на индекс в входной строке, с которого начинается анализ.
/// @param j Индекс в выходной строке, куда записывается результат.
/// @param error Указатель на переменную, которая используется для указания
/// наличия ошибки в анализе.
void parserMod(char *strIn, char *strOut, int *i, int j, int *error) {
  int lenEnd;
  lenEnd = strlen(strIn);
  if ((*i + 2) < lenEnd && strIn[*i] == 'm' && strIn[*i + 1] == 'o' &&
      strIn[*i + 2] == 'd') {
    strOut[j] = 'm';
    *i += 2;
  } else {
    *error = 6;
    strOut[j] = '\0';
  }
}

/// @brief Функция parserUnarMin предназначена для обработки строки, содержащей
/// математические выражения, и преобразования минуса в унарный минус (~) в
/// определенных условиях.
/// @param strIn Входная строка, в которой ищется подстрока, соответствующая
/// функциям sin или sqrt.
/// @param strOut Выходная строка, в которую записывается результат анализа.
/// @param i Указатель на индекс в входной строке, с которого начинается анализ.
/// @param j Индекс в выходной строке, куда записывается результат.
void parserUnarMin(char *strIn, char *strOut, int *i, int j) {
  if (*i == 0 ||
      (*i != 0 && (strIn[*i - 1] == '(' || (isNumberDot(strIn[*i - 1]) == 0 &&
                                            strIn[*i - 1] != ')')))) {
    strOut[j] = '~';
  } else {
    strOut[j] = '-';
  }
}

/// @brief Функция parserUnarPlus предназначена для обработки строки, содержащей
/// математические выражения, и преобразования плюса в унарный плюс (@) в
/// определенных условиях.
/// @param strIn Входная строка, в которой ищется подстрока, соответствующая
/// функциям sin или sqrt.
/// @param strOut Выходная строка, в которую записывается результат анализа.
/// @param i Указатель на индекс в входной строке, с которого начинается анализ.
/// @param j Индекс в выходной строке, куда записывается результат.
void parserUnarPlus(char *strIn, char *strOut, int *i, int *j) {
  if (*i == 0 ||
      (*i != 0 && (strIn[*i - 1] == '(' || (isNumberDot(strIn[*i - 1]) == 0 &&
                                            strIn[*i - 1] != ')')))) {
    strOut[*j] = '@';
  } else {
    strOut[*j] = '+';
  }
}
/// @brief Функция parserX предназначена для обработки строки, содержащей
/// математическое выражение, и преобразования в ней минуса в унарный минус (~)
/// и плюса в унарный плюс (@).
/// @param strIn Входная строка, в которой ищется подстрока, соответствующая
/// функциям sin или sqrt.
/// @param strOut Выходная строка, в которую записывается результат анализа.
/// @param i Указатель на индекс в входной строке, с которого начинается анализ.
/// @param j Индекс в выходной строке, куда записывается результат.
/// @param error Указатель на переменную, которая используется для указания
/// наличия ошибки в анализе.
void parserX(char *strOut, int *j, char *X, int *error) {
  if (X[0] == '-') {
    X[0] = '~';
  } else if (X[0] == '+') {
    X[0] = '@';
  } else if (X[0] == '\0') {
    *error = 7;  // не заданный X
  }

  if (*error == 0) {
    for (int k = 0; X[k] != '\0'; k++) {
      strOut[*j] = X[k];
      (*j)++;
    }

    (*j)--;
  }
}
